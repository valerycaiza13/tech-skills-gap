# -*- coding: utf-8 -*-
"""Skills first

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1fF9z5k72ntIWFz-fqsZi93FC7GHzjVSi
"""

# Commented out IPython magic to ensure Python compatibility.
from google.colab import drive
drive.mount('/content/drive')
"""
skills_gap_analysis.py

Script para:
- Calcular brechas (gaps) de habilidades tÃ©cnicas en el Ã¡rea de TecnologÃ­a.
- Generar resumen por rol.
- Identificar skills mÃ¡s crÃ­ticas.
- Sugerir formaciones por empleado y skill.

Requiere los archivos CSV:
- empleados_tech.csv
- skills_tech_roles.csv
- skills_tech_empleados.csv
- formaciones_tech.csv
"""

import pandas as pd
from pathlib import Path


# -------------------------
# 1. Cargar datos
# -------------------------

def load_data(base_path: str = "."):
    base = Path(base_path)

    empleados = pd.read_csv(base / "empleados_tech.csv")
    skills_roles = pd.read_csv(base / "skills_tech_roles.csv")
    skills_empleados = pd.read_csv(base / "skills_tech_empleados.csv")
    formaciones = pd.read_csv(base / "formaciones_tech.csv")

    return empleados, skills_roles, skills_empleados, formaciones


# -------------------------
# 2. Calcular gaps por empleado y skill
# -------------------------

def calcular_gaps(empleados, skills_roles, skills_empleados):
    """
    Une:
      - empleados_tech (rol_actual por employee_id)
      - skills_tech_empleados (nivel real por skill)
      - skills_tech_roles (nivel requerido por rol y skill)

    Devuelve un DataFrame con:
      employee_id, nombre, rol_actual, skill_name,
      skill_level, required_level, gap, weight, gap_severity
    """

    # Unir empleados con sus skills
    df = empleados.merge(
        skills_empleados,
        on="employee_id",
        how="left"
    )

    # Unir con el perfil ideal del rol
    df = df.merge(
        skills_roles,
        left_on=["rol_actual", "skill_name"],
        right_on=["rol", "skill_name"],
        how="left",
        suffixes=("", "_rol")
    )

    # Calcular gap = nivel requerido - nivel actual
    df["gap"] = df["required_level"] - df["skill_level"]

    # Severidad de la brecha = gap positivo * peso
    df["gap_severity"] = df.apply(
        lambda row: row["gap"] * row["weight"] if row["gap"] > 0 else 0,
        axis=1
    )

    return df


# -------------------------
# 3. Resumen por rol y global
# -------------------------

def resumen_por_rol(df_gaps):
    """
    Crea un resumen por rol:
      - nÂº empleados
      - % empleados con al menos 1 gap
      - gap_severity promedio
    """

    # Empleado tiene gap si alguna de sus skills tiene gap > 0
    empleados_gap = (
        df_gaps
        .groupby("employee_id")["gap"]
        .apply(lambda x: (x > 0).any())
        .reset_index(name="tiene_gap")
    )

    df_emp = df_gaps[["employee_id", "rol_actual"]].drop_duplicates()
    df_emp = df_emp.merge(empleados_gap, on="employee_id", how="left")

    resumen = (
        df_emp
        .groupby("rol_actual")
        .agg(
            n_empleados=("employee_id", "nunique"),
            n_con_gap=("tiene_gap", lambda x: (x == True).sum())
        )
        .reset_index()
    )

    resumen["porcentaje_con_gap"] = (
        resumen["n_con_gap"] / resumen["n_empleados"] * 100
    ).round(1)

    # Severidad promedio por rol
    sev_rol = (
        df_gaps.groupby("rol_actual")["gap_severity"]
        .mean()
        .reset_index(name="gap_severity_promedio")
    )

    resumen = resumen.merge(sev_rol, on="rol_actual", how="left")

    return resumen


# -------------------------
# 4. Skills mÃ¡s crÃ­ticas
# -------------------------

def skills_mas_criticas(df_gaps, top_n=10):
    """
    Devuelve un ranking de skills con mayor severidad de brecha.
    """
    criticas = (
        df_gaps.groupby("skill_name")["gap_severity"]
        .sum()
        .reset_index()
        .sort_values("gap_severity", ascending=False)
        .head(top_n)
    )
    return criticas


# -------------------------
# 5. Recomendaciones de formaciones
# -------------------------

def recomendaciones_formacion(df_gaps, formaciones):
    """
    Para cada empleado y skill con gap > 0,
    sugiere 1 formaciÃ³n (la primera que encuentre para esa skill).

    Devuelve:
      employee_id, nombre, rol_actual, skill_name, gap,
      course_id, course_name, provider, modality
    """

    # Filtrar solo las skills con gap positivo
    df_need = df_gaps[df_gaps["gap"] > 0].copy()

    # Elegir una formaciÃ³n por skill (la primera)
    cursos_por_skill = (
        formaciones
        .sort_values("duration_hours")  # ejemplo: priorizar cursos mÃ¡s cortos
        .groupby("skill_name")
        .head(1)
    )

    # Unir skills con cursos
    df_rec = df_need.merge(
        cursos_por_skill,
        on="skill_name",
        how="left"
    )

    cols = [
        "employee_id",
        "nombre",
        "apellido",
        "rol_actual",
        "skill_name",
        "skill_level",
        "required_level",
        "gap",
        "course_id",
        "course_name",
        "provider",
        "duration_hours",
        "modality",
    ]
    df_rec = df_rec[cols].sort_values(["employee_id", "skill_name"])

    return df_rec


# -------------------------
# 6. FunciÃ³n principal
# -------------------------

def main(base_path: str = ".", output_path: str = "./output"):
    base = Path(base_path)
    out = Path(output_path)
    out.mkdir(parents=True, exist_ok=True)

    # 1. Cargar datos
    empleados, skills_roles, skills_empleados, formaciones = load_data(base_path)

    # 2. Calcular gaps
    df_gaps = calcular_gaps(empleados, skills_roles, skills_empleados)

    # 3. Resumen por rol
    resumen_rol = resumen_por_rol(df_gaps)

    # 4. Skills mÃ¡s crÃ­ticas
    criticas = skills_mas_criticas(df_gaps, top_n=10)

    # 5. Recomendaciones de formaciÃ³n
    rec_formacion = recomendaciones_formacion(df_gaps, formaciones)

    # 6. Guardar resultados a CSV
    df_gaps.to_csv(out / "gaps_detalle_por_empleado_skill.csv", index=False)
    resumen_rol.to_csv(out / "resumen_gaps_por_rol.csv", index=False)
    criticas.to_csv(out / "skills_mas_criticas.csv", index=False)
    rec_formacion.to_csv(out / "recomendaciones_formacion.csv", index=False)

    print("âœ… AnÃ¡lisis completado.")
    print(f"- Detalle de gaps: {out / 'gaps_detalle_por_empleado_skill.csv'}")
    print(f"- Resumen por rol: {out / 'resumen_gaps_por_rol.csv'}")
    print(f"- Skills crÃ­ticas: {out / 'skills_mas_criticas.csv'}")
    print(f"- Recomendaciones formaciÃ³n: {out / 'recomendaciones_formacion.csv'}")


if __name__ == "__main__":
    main()

    !ls
!ls output
# %cd /content/drive/MyDrive/tech-skills-gap
!pwd
!ls
!cp /content/gaps_detalle_por_empleado_skill.csv .
!cp /content/resumen_gaps_por_rol.csv .
!cp /content/skills_mas_criticas.csv .
!cp /content/recomendaciones_formacion.csv .
!cp -r /content/output .
with open("app.py", "w", encoding="utf-8") as f:
    f.write("print('App placeholder - next step')")
print("âœ… app.py creado")
app_code = r'''
import pandas as pd
import streamlit as st
import matplotlib.pyplot as plt
from pathlib import Path

from skills_gap_analysis import load_data, calcular_gaps, resumen_por_rol, skills_mas_criticas, recomendaciones_formacion

st.set_page_config(page_title="Tech Skills Gap Dashboard", layout="wide")

st.title("ðŸ“Š Tech Skills Gap Dashboard")
st.caption("Brechas de habilidades tÃ©cnicas (Technology only) usando CSV demo.")

BASE_PATH = Path(".")  # tus CSV estÃ¡n en la misma carpeta

@st.cache_data
def run_analysis():
    empleados, skills_roles, skills_empleados, formaciones = load_data(BASE_PATH)
    df_gaps = calcular_gaps(empleados, skills_roles, skills_empleados)
    resumen = resumen_por_rol(df_gaps)
    criticas = skills_mas_criticas(df_gaps, top_n=10)
    recs = recomendaciones_formacion(df_gaps, formaciones)
    return empleados, df_gaps, resumen, criticas, recs

try:
    empleados, df_gaps, resumen, criticas, recs = run_analysis()
except Exception as e:
    st.error("No pude cargar/analizar los datos. Revisa que los CSV estÃ©n en la misma carpeta que app.py.")
    st.exception(e)
    st.stop()

# Sidebar filtros
st.sidebar.header("Filtros")
roles = sorted(empleados["rol_actual"].dropna().unique())
rol_sel = st.sidebar.multiselect("Rol", options=roles, default=roles)

skills = sorted(df_gaps["skill_name"].dropna().unique())
skill_sel = st.sidebar.multiselect("Skills", options=skills, default=skills[:min(10, len(skills))])

df_f = df_gaps[
    df_gaps["rol_actual"].isin(rol_sel) &
    df_gaps["skill_name"].isin(skill_sel)
].copy()

# KPIs
col1, col2, col3 = st.columns(3)
col1.metric("Empleados (filtrado)", int(df_f["employee_id"].nunique()))
col2.metric("Skills (filtrado)", int(df_f["skill_name"].nunique()))
col3.metric("Gap severity total", float(df_f["gap_severity"].sum().round(2)))

st.divider()

left, right = st.columns([1, 1])

with left:
    st.subheader("ðŸ“Œ Resumen por rol")
    st.dataframe(resumen[resumen["rol_actual"].isin(rol_sel)], use_container_width=True)

    st.subheader("ðŸ”¥ Skills mÃ¡s crÃ­ticas (Top 10)")
    crit_f = (
        df_f.groupby("skill_name")["gap_severity"].sum()
        .reset_index()
        .sort_values("gap_severity", ascending=False)
        .head(10)
    )
    st.dataframe(crit_f, use_container_width=True)

with right:
    st.subheader("ðŸ“ˆ Severidad por skill (gap severity)")
    chart_df = (
        df_f.groupby("skill_name")["gap_severity"].sum()
        .reset_index()
        .sort_values("gap_severity", ascending=True)
    )
    fig = plt.figure()
    plt.barh(chart_df["skill_name"], chart_df["gap_severity"])
    plt.xlabel("Gap Severity (sum)")
    plt.ylabel("Skill")
    st.pyplot(fig, clear_figure=True)

st.divider()

st.subheader("ðŸ§‘â€ðŸ’» Detalle de gaps (filtrado)")
st.dataframe(
    df_f.sort_values(["rol_actual", "employee_id", "gap_severity"], ascending=[True, True, False]),
    use_container_width=True
)

st.subheader("ðŸŽ“ Recomendaciones de formaciÃ³n (solo gaps > 0)")
recs_f = recs[recs["rol_actual"].isin(rol_sel) & recs["skill_name"].isin(skill_sel)].copy()
st.dataframe(recs_f, use_container_width=True)
'''
with open("app.py", "w", encoding="utf-8") as f:
    f.write(app_code)

print("âœ… app.py actualizado con el dashboard")

reqs = """pandas>=2.0
streamlit>=1.30
matplotlib>=3.7
"""
with open("requirements.txt", "w", encoding="utf-8") as f:
    f.write(reqs)
print("âœ… requirements.txt creado")
!ls
